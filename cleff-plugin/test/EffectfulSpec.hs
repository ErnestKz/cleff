{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE CPP                 #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# OPTIONS_GHC -Wno-unused-type-patterns -Wno-unused-foralls #-}
module EffectfulSpec where

import           Data.String                  (IsString)
import           Effectful
import           Effectful.Dispatch.Dynamic
import           Effectful.Error.Static
import           Effectful.State.Static.Local
import           Effectful.TH
import           Unsafe.Coerce                (unsafeCoerce)

class MPTC a b where
  mptc :: a -> b

instance MPTC Bool Int where
  mptc _ = 1000

uniquelyInt :: '[State Int, State String] :>> r => Eff r ()
uniquelyInt = put 10

uniquelyA :: (Num a, '[State a, State b] :>> r) => Eff r ()
uniquelyA = put 10

uniquelyString :: '[State Int, State String] :>> r => Eff r ()
uniquelyString = put mempty

uniquelyB :: (MPTC Bool b, '[State String, State b] :>> r) => Eff r ()
uniquelyB = put $ mptc False

uniquelyState' :: '[Error (), State ()] :>> r => Eff r ()
uniquelyState' = pure ()

idState :: State s :> r => Eff r ()
idState = do
  s <- get
  put s

intState :: State Int :> r => Eff r ()
intState = put 10

numState :: Num a => State a :> r => Eff r ()
numState = put 10

strState :: State String :> r => Eff r ()
strState = put "Hello"

oStrState :: IsString a => State a :> r => Eff r ()
oStrState = put "hello"

err :: Error e :> r => Eff r Bool
err =
  catchError
    (throwError (error ""))
    (\_ _ -> pure True)

errState :: Num s => '[Error e, State s] :>> r => Eff r Bool
errState = do
  numState
  err

newtype MyString = MyString String
  deriving newtype (IsString, Eq, Show)

data Janky = forall s. Janky (forall _i. Eff '[State s] ())

jankyState :: Janky
jankyState = Janky $ put True -- The plugin disambiguates effects for concrete rows too

unsafeUnjank :: Janky -> Eff '[State Bool] ()
unsafeUnjank (Janky m) = unsafeCoerce m

data MoreJanky = forall y. MoreJanky (MPTC Bool y => Eff '[State (Bool, y), State (Char, y)] ())

mptcGet :: MPTC x Bool => x
mptcGet = undefined

moreJankyState :: MoreJanky
moreJankyState = MoreJanky $ put (mptcGet, True)

data TaggedState k s :: Effect where
  TaggedGet :: forall k s m. TaggedState k s m s
  TaggedPut :: forall k s m. s -> TaggedState k s m ()

makeEffect ''TaggedState -- The plugin also disambiguates TH functions generated by 'makeEffect'

-- TODO(daylily): This doesn't work - investigate later
-- runTaggedState :: forall k s r a
--                 . s
--                -> Eff (TaggedState k s : r) a
--                -> Eff r (a, s)
-- runTaggedState s =
--     (runState s .)
--   $ reinterpret
--   $ const \case
--     TaggedGet    -> get
--     TaggedPut s' -> put s'

-- Inferred specificity for kind parameters since GHC 9
#if __GLASGOW_HASKELL__ >= 900
test :: '[
          TaggedState Char Int
        , TaggedState Bool Int
        ] :>> r
     => Eff r ()
test = do
  taggedPut @Bool 10
  taggedPut @Char (-10)
#else
test :: '[
          TaggedState Char Int
        , TaggedState Bool Int
        ] :>> r
     => Eff r ()
test = do
  taggedPut @_ @Bool 10
  taggedPut @_ @Char (-10)
#endif

newtype Select a = Select a

data DBAction whichDb :: Effect where
  DoSelect :: Select a -> DBAction whichDb m (Maybe a)

makeEffect ''DBAction

runDBAction :: Eff (DBAction which ': r) a -> Eff r a
runDBAction = interpret $ const \case
  DoSelect (Select a) -> pure $ Just a
