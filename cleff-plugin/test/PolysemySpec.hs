{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# OPTIONS_GHC -Wno-unused-foralls #-}
module PolysemySpec where

import           Cleff.Reader
import           Data.String    (IsString)
import           Polysemy
import           Polysemy.Error
import           Polysemy.State
import           Unsafe.Coerce  (unsafeCoerce)

class MPTC a b where
  mptc :: a -> b

instance MPTC Bool Int where
  mptc _ = 1000

uniquelyInt :: Members '[State Int, State String] r => Sem r ()
uniquelyInt = put 10

uniquelyA :: (Num a, Members '[State a, State b] r) => Sem r ()
uniquelyA = put 10

uniquelyString :: Members '[State Int, State String] r => Sem r ()
uniquelyString = put mempty

uniquelyB :: (MPTC Bool b, Members '[State String, State b] r) => Sem r ()
uniquelyB = put $ mptc False

uniquelyState' :: Members '[Error (), State ()] r => Sem r ()
uniquelyState' = pure ()

idState :: Member (State s) r => Sem r ()
idState = do
  s <- get
  put s

intState :: Member (State Int) r => Sem r ()
intState = put 10

numState :: Num a => Member (State a) r => Sem r ()
numState = put 10

strState :: Member (State String) r => Sem r ()
strState = put "Hello"

oStrState :: IsString a => Member (State a) r => Sem r ()
oStrState = put "hello"

err :: Member (Error e) r => Sem r Bool
err =
  catch
    (throw (error ""))
    (\_ -> pure True)

errState :: Num s => Members '[Error e, State s] r => Sem r Bool
errState = do
  numState
  err

newtype MyString = MyString String
  deriving newtype (IsString, Eq, Show)

data Janky = forall s. Janky (forall _i. Sem '[State s] ())

jankyState :: Janky
jankyState = Janky $ put True -- The plugin disambiguates effects for concrete rows too

unsafeUnjank :: Janky -> Sem '[State Bool] ()
unsafeUnjank (Janky m) = unsafeCoerce m

data MoreJanky = forall y. MoreJanky (MPTC Bool y => Sem '[State (Bool, y), State (Char, y)] ())

mptcGet :: MPTC x Bool => x
mptcGet = undefined

moreJankyState :: MoreJanky
moreJankyState = MoreJanky $ put (mptcGet, True)

data TaggedState k s :: Effect where
  TaggedGet :: forall k s m. TaggedState k s m s
  TaggedPut :: forall k s m. s -> TaggedState k s m ()

makeSem ''TaggedState -- The plugin also disambiguates TH functions generated by 'makeSem'

runTaggedState :: forall k s r a
                . s
               -> Sem (TaggedState k s : r) a
               -> Sem r (s, a)
runTaggedState s =
    (runState s .)
  $ reinterpret
  $ \case
    TaggedGet    -> get
    TaggedPut s' -> put s'

test :: Members '[
          TaggedState Char Int
        , TaggedState Bool Int
        ] r
     => Sem r ()
test = do
  taggedPut @Bool 10
  taggedPut @Char (-10)


newtype Select a = Select a

data DBAction whichDb :: Effect where
  DoSelect :: Select a -> DBAction whichDb m (Maybe a)

makeSem ''DBAction

runDBAction :: Sem (DBAction which ': r) a -> Sem r a
runDBAction = interpret $ \case
  DoSelect (Select a) -> pure $ Just a

insertAtWithIndex :: Sem (e1 : e2 : e3 : e4 : r) a -> Sem (e1 : e2 : Reader i : e3 : e4 : r) a
insertAtWithIndex = insertAt @2

insertAtAndRaiseUnder :: Sem (e1 : r) a -> Sem (e1 : e2 : State s : e3 : Reader i : e4 : r) a
insertAtAndRaiseUnder = raise2Under . insertAt @2 . raiseUnder

insertAtEmpty :: Sem (e1 : e2 : r) a -> Sem (e1 : e2 : r) a
insertAtEmpty = insertAt @2
